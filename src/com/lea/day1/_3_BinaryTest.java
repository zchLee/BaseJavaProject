package com.lea.day1;

/**
 * @author lea
 * @create 2020/7/14 10:37
 * 计算机中不同进制的说明
 *  二进制（binary） 0,1 满2进1 ， 以0b或0B开头
 *  十进制（decimal） 0-9 满10进1，
 *  八进制（octal） 0-7 满8进1，以数字0开开头
 *  十六进制（hex） 0-F 满15进1，以0X或0x开头，此处a-f不区分大小写
 *  如：0x21AF + 1 = 0x21B0
 *
 *
 */
public class _3_BinaryTest {
    // 计算机中以二进制的补码形式保存所有数据
    // 二进制转十进制
    /**
     * 正数的原码、补码、反码都是它本身
     * 负数的补码是其反码加1
     * */
    /**
     * 二进制的整数有如下三种形式
     * 原码：直接将一个数值换成二进制数，最高位是符号位
     * 负数的反码：是对原码按位取反，只是最高位确定为1
     * 负数的补码：其反码加1
     *
     *  负数的二进制是反过来求的数
     * */
    /*
    * 设 二进制 1101，一共4位,每位上是二进制本身
    * 从左到右算： 1*2^(4-1)+1*2^(4-2)+0*2^(4-3)+1*2^0
    *         得： 2^3+2^2+0+1 = 8 + 4 + 1 = 13
    * 二进制最高位是符号为 0：整数  1:负数
    * 一般8位
    * */

    // 十进制转二进制
    /**
     * 除2取余的逆
     *
     *   比如 134, 以下中间的数 都开方2 得到下一个数
     *  2  134
     *      67  余   0
     *          33  余   1
     *              16  余   1
     *                  8   余   0
     *                      4   余   0
     *                          2   余   0
     *                              1   余   0
     *
     *    逆着取余，从结果开始，得 10000110
     *
     * */


    // 二进制转八进制
//    从右往左 每三个一组转换成8进制，每组最高7，最后累加
    // 八进制转二进制
    // 从左到右，转成三位的二进制，然后拼接即可


    // 二进制转16进制
    // 和二进制转八进制相似，但是是四个一组，最高15，最后累加
    // 十六进制转二进制
    // 从左到右，转成四位的二进制，然后拼接即可
}
