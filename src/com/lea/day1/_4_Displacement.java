package com.lea.day1;

/**
 * @author a cheng
 * @create 2020/7/24 11:05
 * 位移运算
 */
public class _4_Displacement {
    // 负数位移 是先转成转码 再位移，符号为不变，位移相反位置填0
    // << 左移 ： 被移除的高位丢弃，空位补0
    /*
    *  指将某数二进制表示的数，往左移动 n 位， 并移除左边n位，在右边拼上n位0
    *   例：  10 左移两位
    *        00001010   2^1 + 2^3 = 10
    *     00|00101000   2^3 + 2^5 = 2^2(2^1 + 2^3) = 2^2 * 10 = 40
    *   由上可得：
    *   k左移n位的结果公式为  2的n次方 * k
    * */
    // >> 右移：被移除二进制最高位是0，右移后 空缺位补0，最高位是1，空缺位补1
    /*
    *   指将某数的二进制表示的数，往右移动n位，并移除右边n位，左边除符号位其他填充首位的数：如果是1 就填充1 如果是0填充0
    *   与左移相反，最后的结果是 右移n位，最后结果 = / 2的n次方
    *
    * */

    // >>> 无符号位移 无论最高位是0还是1，空位都用0补
    /*
    *  无符号位移，不管二进制符号位，统统拿0补
    * */

    // & 与运算： 两个数 取二进制按位取& 只有两位都是1，得1，否则得0
    /**
     *     00001110         14
     *     00010010         18
     *    ------------
     *     00000010         2
     * */
    // | 或运算： 两个数 取二进制按位取| 只有一位是1，得1，否则得0
    /**
     *     00001110         14
     *     00010010         18
     *    ------------
     *     00011110         30
     * */
    // ^ 异或运算： 两个数 取二进制按位取^ 只要两位不一样是1，得1，否则得0
    /**     异或：其运算法则相当于不带进位的二进制加法
     *     00001110         14
     *     00010010         18
     *    ------------
     *     00011100         12
     * */
    // ~ 取反运算： 一个数 取二进制按位取~ 每位是0得1，是1得0
    /**     异或：其运算法则相当于不带进位的二进制加法
     *     00001110         14
     *    ------------
     *     11110001         原码
     *     10001110         转码
     *     +      1
     *     10001111         反码 -15
     * */
    public static void main(String[] args) {
//        leftDisplaement(10, 3);
//        String hex = getHexByInt(60);
        System.out.println(Integer.toHexString(255));
//        System.out.println(hex);
        System.out.println(3 >>> 31);
        System.out.println((4 - 1)/4);
        System.out.println(8 + (4 - 1)/4);
        System.out.println(Math.max(((8 + (4 - 1)) / 4), 1));
    }

    /**
     * @Description: k左移n位
     * @Param: [k, leftNum]
     * @return: void
     * @date: 2020/7/24 11:21
     * @author: a cheng
    */
    static void leftDisplaement(int k, int leftNum) {
        System.out.println(String.format("%d << %d = %d", k, leftNum, k << leftNum ));
    }

    // 求0-255之间的16进制的数    255 二进制表示是 1111 1111
    static String getHexByInt(int n) {
        // 15二进制是1111
        int n1 = n&15;  // 取出n最后四位二进制数
        // 十六进制的数 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,大于9就用字母表示
        String end = n1>9 ? (char)((n1-10) + 'A') + "" : n1+"";
        // 上一步已经计算完后四个二进制转十六进制的数，就计算前四个二进制数的十六进制表示的数
        int n2 = n >>> 4;
        n2 = n2&15;
        String first = n2>9 ? (char)((n2-10) + 'A') + "" : n2+"";
        return first+end;
    }
}
